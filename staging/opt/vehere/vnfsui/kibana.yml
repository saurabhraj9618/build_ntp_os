# Kibana is served by a back end server. This setting specifies the port to use.
#server.port: 5601

# Specifies the address to which the Kibana server will bind. IP addresses and host names are both valid values.
# The default is 'localhost', which usually means remote machines will not be able to connect.
# To allow connections from remote users, set this parameter to a non-loopback address.
server.host: "0.0.0.0"

# Enables you to specify a path to mount Kibana at if you are running behind a proxy. This only affects
# the URLs generated by Kibana, your proxy is expected to remove the basePath value before forwarding requests
# to Kibana. This setting cannot end in a slash.
#server.basePath: "/dev"
#server.defaultRoute: "/app/vnfs"

# The maximum payload size in bytes for incoming server requests.
server.maxPayloadBytes: 10485760

# The Kibana server's name.  This is used for display purposes.
#server.name: "your-hostname"

# The URL of the Elasticsearch instance to use for all your queries.
elasticsearch.url: "http://localhost:9200"

# When this setting's value is true Kibana uses the hostname specified in the server.host
# setting. When the value of this setting is false, Kibana uses the hostname of the host
# that connects to this Kibana instance.
#elasticsearch.preserveHost: true

# Kibana uses an index in Elasticsearch to store saved searches, visualizations and
# dashboards. Kibana creates a new index if the index doesn't already exist.
#kibana.index: ".vnfsui"

# The default application to load.
#kibana.defaultAppId: "discover"
kibana.defaultAppId: "dashboards"

# If your Elasticsearch is protected with basic authentication, these settings provide
# the username and password that the Kibana server uses to perform maintenance on the Kibana
# index at startup. Your Kibana users still need to authenticate with Elasticsearch, which
# is proxied through the Kibana server.
#  username: "kibanaserver"
#  password: "kibanaserver"

# Enables SSL and paths to the PEM-format SSL certificate and SSL key files, respectively.
# These settings enable SSL for outgoing requests from the Kibana server to the browser.
server.ssl.enabled: true
server.ssl.certificate: /usr/local/share/ca-certificates/VEHERE.crt
server.ssl.key: /usr/local/share/ca-certificates/VEHERE.key

# Optional settings that provide the paths to the PEM-format SSL certificate and key files.
# These files validate that your Elasticsearch backend uses the same key files.
#elasticsearch.ssl.certificate: /path/to/your/client.crt
#elasticsearch.ssl.key: /path/to/your/client.key

# Optional setting that enables you to specify a path to the PEM file for the certificate
# authority for your Elasticsearch instance.
#elasticsearch.ssl.certificateAuthorities: [ "/path/to/your/CA.pem" ]

# To disregard the validity of SSL certificates, change this setting's value to 'none'.
#elasticsearch.ssl.verificationMode: full

# Time in milliseconds to wait for Elasticsearch to respond to pings. Defaults to the value of
# the elasticsearch.requestTimeout setting.
#elasticsearch.pingTimeout: 1500

# Time in milliseconds to wait for responses from the back end or Elasticsearch. This value
# must be a positive integer.
elasticsearch.requestTimeout: 120000

# List of Kibana client-side headers to send to Elasticsearch. To send *no* client-side
# headers, set this value to [] (an empty list).
#elasticsearch.requestHeadersWhitelist: [ authorization ]

# Header names and values that are sent to Elasticsearch. Any custom headers cannot be overwritten
# by client-side headers, regardless of the elasticsearch.requestHeadersWhitelist configuration.
#elasticsearch.customHeaders: {}

# Time in milliseconds for Elasticsearch to wait for responses from shards. Set to 0 to disable.
#elasticsearch.shardTimeout: 0

# Time in milliseconds to wait for Elasticsearch at Kibana startup before retrying.
#elasticsearch.startupTimeout: 5000

# Specifies the path where Kibana creates the process ID file.
#pid.file: /var/run/kibana.pid

# Enables you specify a file where Kibana stores log output.
#logging.dest: stdout

# Set the value of this setting to true to suppress all logging output.
#logging.silent: false

# Set the value of this setting to true to suppress all logging output other than error messages.
#logging.quiet: false

# Set the value of this setting to true to log all events, including system usage information
# and all requests.
#logging.verbose: false

# Set the interval in milliseconds to sample system and process performance
# metrics. Minimum is 100ms. Defaults to 5000.
#ops.interval: 5000

  # The default locale. This locale can be used in certain circumstances to substitute any missing
# translations.
#i18n.defaultLocale: "en"

# Uncomment to disable Dev Tools
#console.enabled: false

tilemap.url: "http://localhost:3000/map/gm_{x}_{y}_{z}.png"
tilemap.options.maxZoom: 8
tilemap.options.attribution: "Â© [Vehere]"

kibana.statsFields.min_time: "@timestamp"
kibana.statsFields.max_time: "@timestamp"
kibana.statsFields.total_bytes: "session.total_payload_size"
kibana.statsFields.total_packets: "session.total_packets"
kibana.monitoringIndices: ['logvehere-monitor-*']
kibana.alertsIndex: 'logvehere-alerts-*'
kibana.templatePath: '/var/lib/kibana'
kibana.defaultIndexPattern: 'logvehere-probe-*'
kibana.alertsKeyHash: 'session.id'

kibana.discoverDefaultColumns: ['network.src_ip', 'transport.src_port', 'network.dst_ip', 'transport.dst_port', 'session.protocol', 'session.dpi_protocol']
kibana.timeLineAnalysisFields.srcIP: 'network.src_ip'
kibana.timeLineAnalysisFields.dstIP: 'network.dst_ip'
kibana.timeLineAnalysisFields.flowStartMilliSec: 'session.start_time'
kibana.timeLineAnalysisFields.flowEndMilliSec: 'session.end_time'
kibana.timeLineAnalysisFields.appLabel: 'session.protocol'
kibana.timeLineAnalysisFields.dpiProto: 'session.dpi_protocol'
kibana.timeLineAnalysisFields.cumulativeByteCount: 'session.total_payload_size'
kibana.timeLineAnalysisFields.cumulativeOctetCount: 'session.total_bytes'
kibana.timeLineAnalysisFields.cumulativePacketCount: 'session.total_packets'
kibana.timelineGroupByFields: [
  { field: 'session.start_time', value: 'session.start_time' },
  { field: 'session.end_time', value: 'session.end_time' },
  { field: 'network.src_ip', value: 'network.src_ip' },
  { field: 'network.dst_ip', value: 'network.dst_ip' },
  { field: 'session.protocol', value: 'session.protocol.keyword' },
  { field: 'session.dpi_protocol', value: 'session.dpi_protocol.keyword' },
  { field: 'payload.http_host', value: 'payload.http_host.keyword' },
  { field: 'payload.ftp_user_id', value: 'payload.ftp_user_id.keyword' },
  { field: 'payload.ssl_server_name', value: 'payload.ssl_server_name.keyword' },
  { field: 'network.dst_geo_ip.as_org', value: 'network.dst_geo_ip.as_org.keyword' },
  { field: 'network.src_geo_ip.as_org', value: 'network.src_geo_ip.as_org.keyword' },
  { field: 'network.dst_asn_number', value: 'network.dst_asn_number.keyword' },
  { field: 'network.src_asn_number', value: 'network.src_asn_number.keyword' },
  { field: 'network.dst_geo_ip.city_name', value: 'network.dst_geo_ip.city_name.keyword' },
  { field: 'network.src_geo_ip.city_name', value: 'network.src_geo_ip.city_name.keyword' },
  { field: 'network.dst_geo_ip.country_name', value: 'network.dst_geo_ip.country_name.keyword' },
  { field: 'network.src_geo_ip.country_name', value: 'network.src_geo_ip.country_name.keyword' },
  { field: 'payload.http_content_type', value: 'payload.http_content_type.keyword' },
  { field: 'payload.email_content_type', value: 'payload.email_content_type.keyword'}
]
evidence.defaultColumns: ['session.probe_ip', 'network.src_ip', 'transport.src_port', 'network.dst_ip', 'transport.dst_port', 'session.protocol', 'session.received_bytes', 'session.total_packets']
evidence.detailTabs: ['Table', 'organization', 'geographies', 'relatedsession', 'lookups', 'reconstruction', 'addressbook']
evidence.metafields.start_time: 'session.start_time'
evidence.metafields.probe_id: 'session.probe_id'
evidence.metafields.capture_mode: 'session.capture_mode'
evidence.metafields.raw_buffer_index: 'session.raw_buffer_index'
evidence.metafields.raw_array_index: 'session.raw_array_index'
evidence.metafields.src_ip: 'network.src_ip'
evidence.metafields.src_port: 'transport.src_port'
evidence.metafields.dst_ip: 'network.dst_ip'
evidence.metafields.dst_port: 'transport.dst_port'
evidence.metafields.http_referer: 'payload.http_refer'
evidence.metafields.http_host: 'payload.http_host'
evidence.metafields.http_get: 'payload.http_get'
evidence.metafields.app_label: 'session.protocol'
evidence.metafields.proto_id: 'network.ip_protocol'
evidence.metafields.dns_record: 'payload.dns_headers'
evidence.metafields.dns_A_prop: 'a_ip_address'
evidence.metafields.dns_AAAA_prop: 'ipv6_address'
evidence.metafields.dns_QName_prop: 'dns_domain_name'
evidence.metafields.dns_CName_prop: 'cname'
evidence.metafields.dns_NXDomain_prop: 'dns_response_code'
evidence.metafields.hash_key: 'session.id'
evidence.metafields.frame_type: 'datalink.frame_type'
evidence.metafields.src_city: 'network.src_geo_ip.city_name'
evidence.metafields.src_country: 'network.src_geo_ip.country_name'
evidence.metafields.dst_city: 'network.dst_geo_ip.city_name'
evidence.metafields.dst_country: 'network.dst_geo_ip.country_name'
evidence.metafields.src_as_org: 'network.src_geo_ip.as_org'
evidence.metafields.dst_as_org: 'network.dst_geo_ip.as_org'
evidence.addr_host_name: 'name'
evidence.addr_identity: 'identity'
evidence.addr_host_owner: 'owner'
evidence.addr_host_custodian: 'custodian'
evidence.nmap_host: 'nmapData.host'
evidence.nmap_ip: 'nmapData.ip'
evidence.nmap_os: 'nmapData.os'
evidence.nmap_open_ports: 'nmapData.openPorts'

evidence.metafields.os_name: 'session.src_os'
evidence.metafields.os_version: 'session.src_os_version'
evidence.metafields.webuseragent_device: 'payload.machine.Device_Name'
evidence.metafields.webuseragent_os_name: 'payload.machine.Platform'

# In Minutes
evidence.lookup_interval: 60

reconstruction.long_poll_timeout: 1000


security.enabled: true

security.cookie.password: "56be1eab61eb9165b41c4749eb07de7479f487b1"
security.cookie.secure: true

security.basicauth.logpath: "/var/log/vnfsuisecurity"
security.basicauth.login.showbrandimage: true
security.basicauth.login.title: ""
security.basicauth.login.subtitle: ""
vnfspack.licensepath: "/usr/local/etc/license"

# Acknowledged Alerts Index
alerts.acknowledgedindex: 'acknowledgedalerts'
alerts.defaultColumns: ['network.src_ip', 'transport.src_port', 'network.dst_ip', 'transport.dst_port', 'session.analytics.name']

config.captureapptype: 'probe' # Default 'probe' if YAF is used then set value to 'yaf'

#Address Book Indexd
config.addressbookindex: 'address-book'
# vnfs probe config file path
config.vnfs_configfile_path: "/usr/local/etc/vnfs.json"
#Rules Config File
config.vnfs_rules_configfile_path: '/usr/local/etc/rulealerts.cfg'

# capture/group json file path
config.capture_settings_configfile_path: "/usr/local/etc/capture_settings.json"
# capture_filter input file path
config.capture_filter_input_configfile_path: "/usr/local/etc/filter_input.lst"
# capture_filter error file path
config.capture_filter_error_configfile_path: "/usr/local/etc/filter_error.lst"
# network_interfaces config file path
config.network_interfaces_configfile_path: "/usr/local/etc/iface.monitoring.lst"
# network_interfaces_negative config file path
config.network_interfaces_negative_configfile_path: "/usr/local/etc/iface.negative.lst"

#Metricbeat Config File
config.metricbeat_configfile_path: "/etc/metricbeat/metricbeat.yml"
#Services List to Restart
config.advance_config_services_list: ['metricbeat','logstash','mldns','mlnetflow','intelliworker']
